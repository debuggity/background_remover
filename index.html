<!DOCTYPE html>
<html>
<head>
    <title>Background Removal with U2Net</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        #canvas {
            margin-top: 20px;
            border: 1px solid black;
        }
        #selected-image {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <h1>Image Background Removal with U2Net</h1>
    <input id="image-selector" type="file" accept="image/*" style="margin-top:20px;">
    <button id="predict-button" style="margin-top:20px;">Remove Background</button>
    <br>
    <img id="selected-image" src="" alt="Selected Image" style="display: none; max-width: 320px; max-height: 320px;" />
    <canvas id="canvas" style="max-width: 100%; border: 1px solid black;"></canvas>

    <script>
        document.getElementById("image-selector").addEventListener("change", function () {
            let reader = new FileReader();
            reader.onload = function () {
                let dataURL = reader.result;
                let img = new Image();
                img.onload = function () {
                    document.getElementById("selected-image").src = dataURL;
                    document.getElementById("selected-image").style.display = 'block';
                    resizeAndPadImage(img);
                };
                img.src = dataURL;
            }
            let file = document.getElementById("image-selector").files[0];
            reader.readAsDataURL(file);
        });
    
        function resizeAndPadImage(img) {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
    
            // Calculate aspect ratio and resizing
            let ratio = Math.min(320 / img.width, 320 / img.height);
            let newWidth = img.width * ratio;
            let newHeight = img.height * ratio;
    
            // Set canvas to 320x320
            canvas.width = 320;
            canvas.height = 320;
    
            // Calculate padding
            let xOffset = (320 - newWidth) / 2;
            let yOffset = (320 - newHeight) / 2;
    
            // Clear canvas and draw image centered
            ctx.clearRect(0, 0, 320, 320);
            ctx.drawImage(img, xOffset, yOffset, newWidth, newHeight);
        }
    
        document.getElementById("predict-button").addEventListener("click", async function () {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
    
            // Load the U2Net model
            const session = await ort.InferenceSession.create('./u2netp.onnx');
            console.log("Model loaded");
    
            // Create an offscreen canvas to work with the image
            let offscreenCanvas = document.createElement('canvas');
            let offscreenCtx = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = 320;
            offscreenCanvas.height = 320;
            offscreenCtx.drawImage(canvas, 0, 0, 320, 320);
    
            // Get image data and convert to tensor
            let imageData = offscreenCtx.getImageData(0, 0, 320, 320);
            let tensorData = new Float32Array(1 * 3 * 320 * 320);
    
            for (let i = 0; i < imageData.data.length; i += 4) {
                tensorData[i / 4] = imageData.data[i] / 255; // Red
                tensorData[(i / 4) + (320 * 320)] = imageData.data[i + 1] / 255; // Green
                tensorData[(i / 4) + (2 * 320 * 320)] = imageData.data[i + 2] / 255; // Blue
            }
    
            const input = new ort.Tensor('float32', tensorData, [1, 3, 320, 320]);
            const feeds = { 'input.1': input };
            const results = await session.run(feeds);
    
            // Log available output keys
            console.log('Model output keys:', Object.keys(results));
    
            // Assuming first key is correct
            const outputKey = Object.keys(results)[0];
            const output = results[outputKey];
    
            let maskData = output.data;
            let originalImageData = offscreenCtx.getImageData(0, 0, 320, 320);
            let outputImageData = ctx.createImageData(320, 320);
    
            // Apply the mask to the original image
            for (let i = 0; i < maskData.length; i++) {
                let pixelIndex = i * 4;
                outputImageData.data[pixelIndex] = originalImageData.data[pixelIndex]; // Red
                outputImageData.data[pixelIndex + 1] = originalImageData.data[pixelIndex + 1]; // Green
                outputImageData.data[pixelIndex + 2] = originalImageData.data[pixelIndex + 2]; // Blue
                outputImageData.data[pixelIndex + 3] = maskData[i] > 0.5 ? 255 : 0; // Alpha
            }
    
            // Clear the canvas and put the image data back, ensuring we draw only the part that originally held the image
            ctx.clearRect(0, 0, 320, 320);
            ctx.putImageData(outputImageData, 0, 0);
    
            // Restore original aspect ratio
            let img = document.getElementById("selected-image");
            let ratio = Math.min(320 / img.width, 320 / img.height);
            let newWidth = img.width * ratio;
            let newHeight = img.height * ratio;
            let xOffset = (320 - newWidth) / 2;
            let yOffset = (320 - newHeight) / 2;
    
            ctx.clearRect(0, 0, 320, 320);
            ctx.drawImage(canvas, xOffset, yOffset, newWidth, newHeight);
        });
    </script>
      
</body>
</html>
