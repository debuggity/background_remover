<!DOCTYPE html>
<html>
<head>
    <title>Background Removal with U2Net</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        #canvas {
            margin-top: 20px;
            border: 1px solid black;
        }
        #selected-image {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <h1>Image Background Removal with U2Net</h1>
    <input id="image-selector" type="file" accept="image/*" style="margin-top:20px;">
    <button id="predict-button" style="margin-top:20px;">Remove Background</button>
    <br>
    <img id="selected-image" src="" alt="Selected Image" style="display: none;" />
    <canvas id="canvas" width="320" height="320"></canvas>

    <script>
        document.getElementById("image-selector").addEventListener("change", function () {
            let reader = new FileReader();
            reader.onload = function () {
                let dataURL = reader.result;
                document.getElementById("selected-image").src = dataURL;
                document.getElementById("selected-image").style.display = 'block';
            }
            let file = document.getElementById("image-selector").files[0];
            reader.readAsDataURL(file);
        });

        document.getElementById("predict-button").addEventListener("click", async function () {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            // Load the U2Net model
            const session = await ort.InferenceSession.create('./u2netp.onnx');
            console.log("Model loaded");

            let image = document.getElementById("selected-image");
            let offscreenCanvas = document.createElement('canvas');
            let offscreenCtx = offscreenCanvas.getContext('2d');

            // Preserve aspect ratio
            let aspectRatio = image.width / image.height;
            let targetWidth, targetHeight;
            if (image.width > image.height) {
                targetWidth = 320;
                targetHeight = 320 / aspectRatio;
            } else {
                targetHeight = 320;
                targetWidth = 320 * aspectRatio;
            }

            offscreenCanvas.width = targetWidth;
            offscreenCanvas.height = targetHeight;
            offscreenCtx.drawImage(image, 0, 0, targetWidth, targetHeight);

            // Get image data and convert to tensor
            let imageData = offscreenCtx.getImageData(0, 0, targetWidth, targetHeight);
            let tensorData = new Float32Array(1 * 3 * 320 * 320);

            for (let i = 0; i < imageData.data.length; i += 4) {
                let x = Math.floor(i / 4) % targetWidth;
                let y = Math.floor(Math.floor(i / 4) / targetWidth);
                let newX = Math.floor(x * 320 / targetWidth);
                let newY = Math.floor(y * 320 / targetHeight);
                let newIndex = (newY * 320 + newX) * 4;

                tensorData[newIndex / 4] = imageData.data[i] / 255; // Red
                tensorData[(newIndex / 4) + (320 * 320)] = imageData.data[i + 1] / 255; // Green
                tensorData[(newIndex / 4) + (2 * 320 * 320)] = imageData.data[i + 2] / 255; // Blue
            }

            const input = new ort.Tensor('float32', tensorData, [1, 3, 320, 320]);
            const feeds = { 'input.1': input };
            const results = await session.run(feeds);

            // Log available output keys
            console.log('Model output keys:', Object.keys(results));

            // Assuming first key is correct
            const outputKey = Object.keys(results)[0];
            const output = results[outputKey];

            let maskData = output.data;
            let outputImageData = ctx.createImageData(targetWidth, targetHeight);

            // Apply the mask to the original image
            for (let y = 0; y < targetHeight; y++) {
                for (let x = 0; x < targetWidth; x++) {
                    let newX = Math.floor(x * 320 / targetWidth);
                    let newY = Math.floor(y * 320 / targetHeight);
                    let maskIndex = newY * 320 + newX;

                    let pixelIndex = (y * targetWidth + x) * 4;
                    outputImageData.data[pixelIndex] = imageData.data[(y * targetWidth + x) * 4]; // Red
                    outputImageData.data[pixelIndex + 1] = imageData.data[(y * targetWidth + x) * 4 + 1]; // Green
                    outputImageData.data[pixelIndex + 2] = imageData.data[(y * targetWidth + x) * 4 + 2]; // Blue
                    outputImageData.data[pixelIndex + 3] = maskData[maskIndex] > 0.5 ? 255 : 0; // Alpha
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offscreenCanvas, (320 - targetWidth) / 2, (320 - targetHeight) / 2, targetWidth, targetHeight);
        });
    </script>
</body>
</html>
