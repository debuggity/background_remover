<!DOCTYPE html>
<html>
<head>
    <title>Background Removal with U2Net</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        #canvas {
            margin-top: 20px;
            border: 1px solid black;
        }
        #selected-image {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <h1>Image Background Removal with U2Net</h1>
    <input id="image-selector" type="file" accept="image/*" style="margin-top:20px;">
    <button id="predict-button" style="margin-top:20px;">Remove Background</button>
    <br>
    <img id="selected-image" src="" alt="Selected Image" style="display: none; max-width: 320px; max-height: 320px;" />
    <canvas id="canvas" style="max-width: 100%; border: 1px solid black;"></canvas>

    <script>
        document.getElementById("image-selector").addEventListener("change", function () {
            let reader = new FileReader();
            reader.onload = function () {
                let dataURL = reader.result;
                let img = new Image();
                img.onload = function () {
                    document.getElementById("selected-image").src = dataURL;
                    document.getElementById("selected-image").style.display = 'block';
                    resizeCanvas(img);
                };
                img.src = dataURL;
            }
            let file = document.getElementById("image-selector").files[0];
            reader.readAsDataURL(file);
        });
    
        function resizeCanvas(img) {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
    
            // Set canvas dimensions to match image aspect ratio
            const aspectRatio = img.width / img.height;
            const maxCanvasWidth = 320; // Maximum canvas width
            canvas.width = maxCanvasWidth;
            canvas.height = maxCanvasWidth / aspectRatio;
    
            // Draw the image to fit within the canvas while maintaining aspect ratio
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }
    
        document.getElementById("predict-button").addEventListener("click", async function () {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
    
            // Load the U2Net model
            const session = await ort.InferenceSession.create('./u2netp.onnx');
            console.log("Model loaded");
    
            let image = document.getElementById("selected-image");
            let offscreenCanvas = document.createElement('canvas');
            let offscreenCtx = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            offscreenCtx.drawImage(image, 0, 0, canvas.width, canvas.height);
    
            // Get image data and convert to tensor
            let imageData = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height);
            let tensorData = new Float32Array(1 * 3 * canvas.width * canvas.height);
    
            for (let i = 0; i < imageData.data.length; i += 4) {
                tensorData[i / 4] = imageData.data[i] / 255; // Red
                tensorData[(i / 4) + (canvas.width * canvas.height)] = imageData.data[i + 1] / 255; // Green
                tensorData[(i / 4) + (2 * canvas.width * canvas.height)] = imageData.data[i + 2] / 255; // Blue
            }
    
            const input = new ort.Tensor('float32', tensorData, [1, 3, canvas.width, canvas.height]);
            const feeds = { 'input.1': input };
            const results = await session.run(feeds);
    
            // Log available output keys
            console.log('Model output keys:', Object.keys(results));
    
            // Assuming first key is correct
            const outputKey = Object.keys(results)[0];
            const output = results[outputKey];
    
            let maskData = output.data;
            let originalImageData = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height);
            let outputImageData = ctx.createImageData(canvas.width, canvas.height);
    
            // Apply the mask to the original image
            for (let i = 0; i < maskData.length; i++) {
                let pixelIndex = i * 4;
                outputImageData.data[pixelIndex] = originalImageData.data[pixelIndex]; // Red
                outputImageData.data[pixelIndex + 1] = originalImageData.data[pixelIndex + 1]; // Green
                outputImageData.data[pixelIndex + 2] = originalImageData.data[pixelIndex + 2]; // Blue
                outputImageData.data[pixelIndex + 3] = maskData[i] > 0.5 ? 255 : 0; // Alpha
            }
    
            ctx.putImageData(outputImageData, 0, 0);
        });
    </script>    
</body>
</html>
